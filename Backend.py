# File:        Backend.py
# Description: This class reads in the CSV data files created by FileGenerator.py and uses the PySpark library 
#              to run Linear Regression algorithms and predict Fantasy Points for a particular NBA Player 

# Import all libraries required for setting up Spark and functions required for Spark DF (dataframe) manipulation
from pyspark import SparkContext
from pyspark.sql import SparkSession, SQLContext
from pyspark.sql.functions import when, col, lit, pow, sum

# Import from pyspark.ml library, everything required for setting up regression and model validator
from pyspark.ml.linalg import Vectors
from pyspark.ml.regression import LinearRegression, LinearRegressionModel
from pyspark.ml.evaluation import RegressionEvaluator
from pyspark.ml.tuning import ParamGridBuilder, TrainValidationSplit, CrossValidator

# Import library required for connecting to S3 and time/date manipulation
import boto3
from datetime import datetime, timedelta

# Define Backend class which will be used as an object by the FrontendGUI
class Backend:

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
#    """
    # Set up instance field required on intitial run
    def __init__(self):

        # Set up all required obects necessary for spark and linear regression. Load model if available, otherwise skip
        sc = SparkContext()
        self.spark = SparkSession.builder.appName('NBA Fantasy Point Prediction').getOrCreate()
        self.evaluator = RegressionEvaluator(metricName='r2',predictionCol='prediction', labelCol='label')
        self.modelName = "NBAFantasyPointPrediction.model"
        try:
            self.predictModel = LinearRegressionModel.load(self.modelName)
        except:
            print "Regression Model Not Found. Continuing"

        # Creates an S3 client to upload/download files to and from S3
        self.s3 = boto3.client('s3', aws_access_key_id='AKIAIWHJAEPCAYUY74IA',\
                          aws_secret_access_key='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')
        self.bucket = 'hadoop-data-bucket'

        # Obtain list of all players playing in the current season with their team info from S3 and put it into a Spark DF
        csvName_G = 'PlayerList_2017-18.csv'
        self.s3.download_file(self.bucket, "NEW/" + csvName_G, csvName_G)
        self.playerList = self.spark.read.format('csv').option('header','true').option('mode','DROPMALFORMED').option('inferSchema','true').load(csvName_G)

        # Obtain list of all players playing in the current season and average stats and put it into a Spark DF
        csvName_G = 'PlayerAVG.csv'
        self.s3.download_file(self.bucket, "NEW/" + csvName_G, csvName_G)
        self.playerAVG = self.spark.read.format('csv').option('header','true').option('mode','DROPMALFORMED').option('inferSchema','true').load(csvName_G)

        # Obtain list of all games being played in the current season and put it into a Spark DF
        csvName_G = 'GameSchedule.csv'
        self.s3.download_file(self.bucket, "NEW/" + csvName_G, csvName_G)
        self.gameSchedule = self.spark.read.format('csv').option('header','true').option('mode','DROPMALFORMED').option('inferSchema','true').load(csvName_G)

        # Create a list of all available teams in the current season - used to generate team categorial data
        self.teamList = ['ATL','BKN','BOS','CHA','CHI','CLE','DAL','DEN','DET','GSW','HOU','IND','LAC','LAL','MEM','MIA','MIL','MIN','NOP','NYK','OKC','ORL','PHI','PHX','POR','SAC','SAS','TOR','UTA','WAS']

    # Function used to update the current model with the most recent data generated by FileGenerator.py
    def updateModel(self,season):

        # Download game data from S3 and load it into a spark DF
        csvName = season+'Data.csv'
        self.s3.download_file(self.bucket, "NEW/" + csvName, csvName)
        seasonData = self.spark.read.format('csv').option('header', 'true').option('mode', 'DROPMALFORMED').option('inferSchema','true').load(csvName)

        # Split data into a 70% training and 30% test and put into a spark DF, format with labels and features
        traindf, testdf = seasonData.randomSplit([0.7, 0.3], 777)
        train = seasonData.rdd.map(lambda x: [x[0], Vectors.dense(x[1:])]).toDF(['label', 'features'])
        test = seasonData.rdd.map(lambda x: [x[0], Vectors.dense(x[1:])]).toDF(['label', 'features'])

        # Set up linear regression model, parameter builder and cross validator
        lr = LinearRegression(featuresCol = 'features', labelCol = 'label')
        regParamVals = [0.01, 0.05, 0.1, 0.2, 0.5, 1]
        elastParamVals = [0.01, 0.05, 0.1, 0.2, 0.5, 1]
        paramGrid = ParamGridBuilder().addGrid(lr.regParam, regParamVals).addGrid(lr.elasticNetParam, elastParamVals ).build()
        xValidator = CrossValidator(estimator=lr, estimatorParamMaps=paramGrid, evaluator=self.evaluator, numFolds=4)

        # Set up cross validator model and apply training and test data and get results
        xValidMod = xValidator.fit(train)
        trainRes = xValidMod.transform(train)
        testRes = xValidMod.transform(test)

        # Evaluate and print R2 value using training and test data
        print self.evaluator.evaluate(trainRes)
        print self.evaluator.evaluate(testRes)

        # Take the best model and overwirte the existing model, save model and upload to S3
        predictModel = xValidMod.bestModel
        predictModel.write().overwrite().save(self.modelName)
        self.s3.upload_file(self.modelName, self.bucket, "NEW/" + self.modelName)

    # Obtain list of all games to be played from current date to numDays into the future
    def getFutureGamesDF(self,numDays):
        future = datetime.now() + timedelta(days=numDays)
        return self.gameSchedule.filter((self.gameSchedule.DATE_TIME >= datetime.now())&(self.gameSchedule.DATE_TIME <= future))

    # Obtain fantasy points for list of players for a given number of days into the future
    def getTeamFP(self,listPlayers,numDays):

        # Find all games scheduled int the next numDays and create list to store Fantasy Points
        gamesScheduled = self.getFutureGamesDF(numDays)
        FPlist = []

        # Iterate through each player in list, parsing last and first name, find ID and use it to find player FP
        for playerName in listPlayers:
            name = playerName.split(', ')
            print "Last",name[0]
            print "First",name[1]
            id = self.playerList.where((self.playerList.LAST == name[0])&(self.playerList.FIRST==name[1])).select("ID").collect()[0][0]
            FPlist.append(self.predictPlayerFP(id,gamesScheduled))

        return FPlist

    # Calculate the Fantasy Points for a particular player given ID and all the games
    def predictPlayerFP(self,id, games):

        # Obtain the player's minutes, turnovers and personal fouls as a list
        average = self.playerAVG.where(col("ID")==id).select("MINS","TOV","PF").collect()[0]

        # Find all games played by the player and append average stat as well as an empty FP field
        temp1 = self.getGamesPlayedDF(id,games)
        temp2 = temp1.withColumn("MINS",lit(average[0]))
        temp3 = temp2.withColumn("TOV",lit(average[1]))
        temp4 = temp3.withColumn("PF",lit(average[2]))
        temp5 = temp4.withColumn("FP", lit(0))

        # Get data into correct format, apply input into model and get result, return 0 if no data is available
        try:
            inputDF = temp5.select(['FP', 'MINS', 'TOV', 'PF', 'AWAY', 'HOME'] + self.teamList)
            inputRDD = inputDF.rdd.map(lambda x: [x[0], Vectors.dense(x[1:])]).toDF(['label', 'features'])
            result = self.predictModel.transform(inputRDD)
        except:
            return 0

        # Return the sum of all Fantasy Points for the player and round to the nearest tenth
        return round(result.groupBy().sum("prediction").collect()[0][0],1)

    # Get all games played by a particular player given ID and games
    def getGamesPlayedDF(self,id,games):

        # Identify team the player plays for and determine which games involved that team
        team = self.playerList.where(self.playerList.ID == id).select("ABBR").collect()[0][0]
        teamGames = games.filter((games.HOME == team)|(games.AWAY == team))

        # Rename existing column and create "HOME"/"AWAY" categorical data
        temp1 = teamGames.withColumnRenamed("HOME", "H").withColumnRenamed("AWAY", "A")
        temp2 = temp1.withColumn('TEAM', when(col('H')== team,col('A')).otherwise(col('H')))
        temp3 = temp2.withColumn('HOME', when(col('H')== team,1).otherwise(0))
        gamesPlayed = temp3.withColumn('AWAY', when(col('A') == team, 1).otherwise(0))

        # Create team categorial data by iterating through team list and assigning 1 if played against that team
        for ABBR in self.teamList:
            gamesPlayed = gamesPlayed.withColumn(ABBR,when(col('TEAM') == ABBR,1).otherwise(0))

        # Return games played dropping unnecessary column fields
        return gamesPlayed.drop("DATE_TIME","A","H","TEAM")

    # Gets player list and returns as a list of strings - used for listing players in listbox to make selections from
    def getPlayerList(self):

        # Obtain list of all player last and first names and store it, create an empty list to store combined name
        nameListSeparate = self.playerList.select('LAST','FIRST').collect()
        nameListCombined = []

        # Iterate through each name, combining first and last name, append to empty list and return it once done
        num = self.playerList.count()
        for i in range(0,num):
            nameListCombined.append(nameListSeparate[i][0]+', '+nameListSeparate[i][1])
        return nameListCombined

